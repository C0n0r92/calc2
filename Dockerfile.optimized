# Optimized multi-stage production Dockerfile
# This creates a much smaller final image

# Stage 1: Build React Frontend
FROM node:18-alpine AS frontend-builder
WORKDIR /app
COPY webapp/package*.json ./
RUN npm ci && npm cache clean --force
COPY webapp/ ./
RUN npm run build

# Stage 2: Build Rails Backend
FROM ruby:3.2.2-alpine AS backend-builder
RUN apk add --no-cache \
    build-base \
    postgresql-dev \
    tzdata \
    git

WORKDIR /app
COPY backend-api/Gemfile backend-api/Gemfile.lock ./
RUN bundle config --global frozen 1 && \
    bundle install --without development test && \
    bundle clean --force

COPY backend-api/ ./
RUN mkdir -p tmp/pids log storage

# Stage 3: Production Runtime (minimal)
FROM ruby:3.2.2-alpine

# Install only runtime dependencies
RUN apk add --no-cache \
    postgresql-client \
    nginx \
    tzdata && \
    rm -rf /var/cache/apk/*

# Create app user
RUN addgroup -g 1000 appgroup && \
    adduser -u 1000 -G appgroup -s /bin/sh -D appuser

WORKDIR /app

# Copy Rails app with minimal footprint
COPY --from=backend-builder --chown=appuser:appgroup /usr/local/bundle /usr/local/bundle
COPY --from=backend-builder --chown=appuser:appgroup /app ./

# Copy built frontend files
COPY --from=frontend-builder --chown=appuser:appgroup /app/dist ./public

# Copy optimized nginx config
COPY nginx-production.conf /etc/nginx/nginx.conf

# Create startup script
RUN echo '#!/bin/sh\n\
set -e\n\
echo "Starting Nginx..."\n\
nginx &\n\
echo "Running database migrations..."\n\
bundle exec rails db:migrate\n\
echo "Starting Rails server..."\n\
exec bundle exec rails server -b 127.0.0.1 -p 3001' > /app/start.sh && \
    chmod +x /app/start.sh && \
    chown appuser:appgroup /app/start.sh

# Set environment variables
ENV RAILS_ENV=production \
    RAILS_SERVE_STATIC_FILES=false \
    RAILS_LOG_TO_STDOUT=true \
    PORT=80

# Switch to non-root user
USER appuser

# Expose port 80
EXPOSE 80

# Start the application
CMD ["/app/start.sh"]
